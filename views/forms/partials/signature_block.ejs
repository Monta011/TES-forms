<div class="space-y-4">
  <% if (title) { %>
    <h3 class="text-lg font-semibold text-gray-800"><%= title %></h3>
    <p class="text-sm text-gray-600"><%= subtitle || '' %></p>
  <% } %>

  <div>
    <div class="border rounded-lg overflow-hidden bg-white">
      <canvas id="<%= idPrefix %>Canvas" class="w-full h-48"></canvas>
    </div>

    <!-- Controls + Inline date on desktop, stacked on mobile -->
    <div class="mt-2 flex flex-col md:flex-row md:items-center md:justify-between gap-2">
      <div class="flex gap-2 flex-wrap">
        <button type="button" class="px-3 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm" data-action="clear" data-target="<%= idPrefix %>">Clear</button>
        <button type="button" id="<%= idPrefix %>SaveBtn" class="px-3 py-2 rounded bg-blue-600 hover:bg-blue-700 text-white text-sm disabled:opacity-50 disabled:cursor-not-allowed" data-action="save" data-target="<%= idPrefix %>">Save Signature</button>
        <label class="px-3 py-2 rounded bg-green-600 hover:bg-green-700 text-white text-sm cursor-pointer">
          Upload
          <input type="file" accept="image/*" class="hidden" data-action="upload" data-target="<%= idPrefix %>">
        </label>
      </div>
      <div class="md:flex md:items-center md:gap-2 w-full md:w-auto">
        <label for="<%= idPrefix %>Date" class="block md:inline text-sm font-medium text-gray-700 md:mb-0 mb-1">Date</label>
        <input type="date" id="<%= idPrefix %>Date" name="<%= dateFieldName %>" value="<%= formData[dateFieldName] || '' %>" class="w-full md:w-48 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
      </div>
    </div>

    <input type="hidden" name="<%= fieldName %>" id="<%= idPrefix %>Input" value="<%= formData[fieldName] || '' %>">
    <% if (errors && errors[fieldName]) { %>
      <p class="text-red-500 text-sm mt-1"><%= errors[fieldName] %></p>
    <% } %>
    <% if (errors && errors[dateFieldName]) { %>
      <p class="text-red-500 text-sm mt-1"><%= errors[dateFieldName] %></p>
    <% } %>
  </div>
</div>
<script>
  (function() {
    const idPrefix = '<%= idPrefix %>';
    const canvas = document.getElementById(idPrefix + 'Canvas');
    if (!canvas) {
      console.error('Canvas not found for', idPrefix);
      return;
    }
    const ctx = canvas.getContext('2d');
    const input = document.getElementById(idPrefix + 'Input');
    const saveBtn = document.getElementById(idPrefix + 'SaveBtn');
    let isPreviewMode = false;

    function updateSaveButton() {
      if (saveBtn) {
        saveBtn.disabled = isPreviewMode;
      }
    }

    function resize() {
      const rect = canvas.getBoundingClientRect();
      const ratio = window.devicePixelRatio || 1;
      canvas.width = rect.width * ratio;
      canvas.height = 192 * ratio; // h-48 â‰ˆ 192px
      canvas.style.width = rect.width + 'px';
      canvas.style.height = '192px';
      
      // Clear canvas and set white background
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.scale(ratio, ratio);
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#000000';
      
      // Restore saved signature if exists
      loadSavedSignature();
    }
    resize();
    window.addEventListener('resize', resize);

    // Smooth line drawing
    let drawing = false;
    let lastPoint = null;
    
    function start(e) {
      // If in preview mode, clear the canvas first
      if (isPreviewMode) {
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#000000';
        isPreviewMode = false;
        updateSaveButton();
      }
      
      drawing = true;
      lastPoint = getPos(e);
      
      // Start the path
      ctx.beginPath();
      ctx.moveTo(lastPoint.x, lastPoint.y);
    }
    
    function move(e) {
      if (!drawing) return;
      e.preventDefault();
      
      const currentPoint = getPos(e);
      
      // Draw line from last point to current point
      ctx.lineTo(currentPoint.x, currentPoint.y);
      ctx.stroke();
      
      // Update last point
      ctx.beginPath();
      ctx.moveTo(currentPoint.x, currentPoint.y);
      
      lastPoint = currentPoint;
    }
    
    function end() { 
      drawing = false;
      lastPoint = null;
    }

    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches && e.touches[0];
      const x = (touch ? touch.clientX : e.clientX) - rect.left;
      const y = (touch ? touch.clientY : e.clientY) - rect.top;
      return { x, y };
    }

    canvas.addEventListener('mousedown', start);
    canvas.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);

    canvas.addEventListener('touchstart', start, { passive: true });
    canvas.addEventListener('touchmove', move, { passive: false });
    window.addEventListener('touchend', end);

    // Load saved signature from hidden input
    function loadSavedSignature() {
      const savedData = input.value;
      if (savedData && savedData.startsWith('data:image')) {
        const img = new Image();
        img.onload = function() {
          // Clear with white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Calculate scaling to fit within canvas while maintaining aspect ratio
          const canvasWidth = canvas.width / ctx.getTransform().a;
          const canvasHeight = canvas.height / ctx.getTransform().d;
          const scale = Math.min(canvasWidth / img.width, canvasHeight / img.height, 1);
          
          // Center the image
          const x = (canvasWidth - img.width * scale) / 2;
          const y = (canvasHeight - img.height * scale) / 2;
          
          ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
          isPreviewMode = true;
          updateSaveButton();
        };
        img.src = savedData;
      }
    }

    // Buttons
    const dateInput = document.getElementById(idPrefix + 'Date');
    function todayISO() {
      const d = new Date();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return d.getFullYear() + '-' + m + '-' + day;
    }

    document.querySelectorAll('[data-target="' + idPrefix + '"]').forEach(btn => {
      const action = btn.getAttribute('data-action');
      if (action === 'clear') {
        btn.addEventListener('click', () => {
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = '#000000';
          input.value = '';
          isPreviewMode = false;
          updateSaveButton();
          if (dateInput) dateInput.value = '';
        });
      } else if (action === 'save') {
        btn.addEventListener('click', () => {
          // Don't save if in preview mode (already saved)
          if (isPreviewMode) {
            return;
          }
          
          // Trim to just the signature strokes (ignore white background)
          // We need to find non-white, non-transparent pixels
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const pixels = imageData.data;
          
          // Find bounding box of signature strokes (non-white pixels)
          let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
          let hasContent = false;
          for (let y = 0; y < canvas.height; y++) {
            for (let x = 0; x < canvas.width; x++) {
              const i = (y * canvas.width + x) * 4;
              const r = pixels[i];
              const g = pixels[i + 1];
              const b = pixels[i + 2];
              const a = pixels[i + 3];
              // Check if pixel is NOT white and NOT transparent (i.e. it's a stroke)
              const isWhite = r > 240 && g > 240 && b > 240;
              if (a > 0 && !isWhite) {
                hasContent = true;
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
              }
            }
          }
          
          // If signature exists, crop and save with transparent background
          if (hasContent && maxX >= minX && maxY >= minY) {
            const padding = 10;
            const cropX = Math.max(0, minX - padding);
            const cropY = Math.max(0, minY - padding);
            const cropWidth = Math.min(canvas.width - cropX, maxX - minX + padding * 2);
            const cropHeight = Math.min(canvas.height - cropY, maxY - minY + padding * 2);
            
            // Create temporary canvas for cropped signature
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = cropWidth;
            tempCanvas.height = cropHeight;
            
            // Get the cropped image data
            const croppedData = ctx.getImageData(cropX, cropY, cropWidth, cropHeight);
            const croppedPixels = croppedData.data;
            
            // Make white pixels transparent (keep only the signature strokes)
            for (let i = 0; i < croppedPixels.length; i += 4) {
              const r = croppedPixels[i];
              const g = croppedPixels[i + 1];
              const b = croppedPixels[i + 2];
              if (r > 240 && g > 240 && b > 240) {
                croppedPixels[i + 3] = 0; // Make transparent
              }
            }
            
            tempCtx.putImageData(croppedData, 0, 0);
            
            // Save as PNG to preserve transparency (signature only, no background)
            input.value = tempCanvas.toDataURL('image/png');
            isPreviewMode = true;
            updateSaveButton();
            
            // Reload to show the saved signature
            loadSavedSignature();
          }
          
          if (dateInput && !dateInput.value) dateInput.value = todayISO();
        });
      } else if (action === 'upload') {
        btn.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = function(event) {
              const img = new Image();
              img.onload = function() {
                // Create a properly sized canvas with minimum size for better visibility
                const minWidth = 400;
                const minHeight = 200;
                const maxWidth = 800;
                const maxHeight = 400;
                
                let width = img.width;
                let height = img.height;
                
                // Scale up if too small (for better PDF visibility)
                if (width < minWidth || height < minHeight) {
                  const scale = Math.max(minWidth / width, minHeight / height);
                  width = width * scale;
                  height = height * scale;
                }
                
                // Scale down if too large
                if (width > maxWidth || height > maxHeight) {
                  const scale = Math.min(maxWidth / width, maxHeight / height);
                  width = width * scale;
                  height = height * scale;
                }
                
                // Create temp canvas with proper size
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCtx.drawImage(img, 0, 0, width, height);
                
                // Save as PNG to preserve transparency
                input.value = tempCanvas.toDataURL('image/png');
                if (dateInput && !dateInput.value) dateInput.value = todayISO();
                
                // Load as preview
                isPreviewMode = true;
                updateSaveButton();
                loadSavedSignature();
              };
              img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            // Reset file input
            e.target.value = '';
          }
        });
      }
    });
    
    // Initial load
    loadSavedSignature();
    updateSaveButton();
  })(); // End of IIFE
</script>

